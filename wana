#!/bin/sh

POSIXLY_CORRECT=yes
filters_count=0

# Error function
error() {
	case $1 in
		correct_form)
			echo "Usage: ./wana [FILTER] [COMMAND] [LOG1[LOG2[...]]" >&2;;
		invalid_date)
			echo "Invalid date, format: \"YYYY-MM-DD HH:MM:SS\"" >&2;;
		invalid_input)
			echo "Invalid input file" >&2;;
		invalid_ip)
			echo "Invalid ip adress" >&2;;

	esac
	exit 1
}

# Checks if the date is correctly inserted
datetimeCheck(){
	correct=$(echo "$1" | awk '/^[1-2][0-9]{3}-[0-1][0-9]-[0-3][0-9]\ [0-2][0-9]:[0-5][0-9]:[0-5][0-9]$/')
	if [ -n "$correct" ]
		then
			return
		else
			error invalid_date
		fi
}

ipCheck(){
	correct=$(echo "$1" | 
	awk '/^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/ ')
	if [ -n "$correct" ]
		then
			return
		else
			error invalid_ip
		fi	
}

# Listing hostnames from ip-adr
# If ip-adr dont have hostname, echo ip-adr
listHosts() {
	for line in $1
	do
		converted=$(host "$line")
	 	if [ $? -eq 1 ]
		then
	 		echo "$line" 
	 	else
	 		echo "$converted" | rev | cut -d' ' -f1 | rev
	 	fi
	done
}

# Separates only the time from input
getDateTime(){

	echo "$1" | awk ' { print $4 } ' | sed ' s/\[//g '
	
}

# Converts the months from alphabet form to number form
dateConvert(){

	 
	echo "$1" | awk ' /^[0-9]/ ' | tr '\/' ' ' | sed ' s/:/ /1' |
	 			sed ' s/Jan/01/g' |
	 			sed ' s/Feb/02/g' |
	 			sed ' s/Mar/03/g' |
	 			sed ' s/Apr/04/g' |
	 			sed ' s/May/05/g' |
	 			sed ' s/Jun/06/g' |
	 			sed ' s/Jul/07/g' |
	 			sed ' s/Aug/08/g' |
	 			sed ' s/Sep/09/g' |
	 			sed ' s/Oct/10/g' |
	 			sed ' s/Nov/11/g' |
	 			sed ' s/Dec/12/g' |
	 			awk ' { print $3 "-" $2 "-" $1 " " $4 } '
}

# Echo only dates that are after the comparator date
afterThisTime(){

	echo "$1"
	comparator=$(echo "$2" | sed ' s/\-//g' | sed ' s/://g' | sed ' s/ //g')
	
	for line in "$1"
	do
		input=$(echo "$line" | sed ' s/\-//g' | sed ' s/://g' | sed ' s/ //g')
		if [ "$input" -gt "$comparator" ]
		then
			echo "$line"
		fi
	done

}

# Echo only dates that are before the comparator date
beforeThisTime(){

	input=$(echo "$1" | sed ' s/\-//g' | sed ' s/://g' | sed ' s/ //g')
	comparator=$(echo "$2" | sed ' s/\-//g' | sed ' s/://g' | sed ' s/ //g')
	
	for line in $input
	do
		if [ "$line" -lt "$comparator" ]
		then
			echo "$line"
		fi
	done

}

# Applying the filters on logs
filters (){
	if [ $filters_count -eq 0 ]
	then
		cat
	fi
	
	input="$(cat)"
	while [ $filters_count -gt 0 ]; do

		if [ "$after_datetime" ]
		then

			comparator=$(echo "$after_datetime" | sed ' s/\-//g' | sed ' s/://g' | sed ' s/ //g')
			for line in "$input"
			do
				one_time="$(dateConvert "$(getDateTime "$line")")" 
				epoch=$(echo "$one_time" | sed ' s/\-//g' | sed ' s/://g' | sed ' s/ //g')
					# if [ "$epoch" -gt "$comparator" ]
					# then
					# 	echo "$line"
					# fi
			done

		elif [ "$before_datetime" ]
		then 
			beforeThisTime "$(dateConvert "$(getDateTime "$(cat)")")" "$before_datetime"
		elif [ "$ip_arg" ]
		then
			
			cat | grep "$ip_arg"
		elif [ "$uri_arg" ]
		then
			cat | grep "$uri_arg"
		fi
		filters_count=$((filters_count-1))
		shift 1

	done

}

logsRead(){
	if [ $# -eq 0 ]
	then
		cat
	fi
	# Processing the logs and print the final result
	while [ $# -gt 0 ]; do
		
		if [ "$(echo "$1" | grep .gz)" ]
		then
			gzip -dc "$1"
			shift 1

		elif [ -f "$1" ]
		then 
			cat "$1"
			shift 1
		else
			error invalid_input
		fi

	done
}


#####################################################################################
##################################   MAIN   #########################################
#####################################################################################

# Checks for all filters
while [ $# -gt 0 ]; do
	case $1 in
		-a )
			datetimeCheck "$2"
			after_datetime=$2
			filters_count=$((filters_count+1))
			shift 2
			;;

		-b )
			datetimeCheck "$2"
			before_datetime=$2
			shift 2
			filters_count=$((filters_count+1))
			;;

		-ip )
			#ipCheck "$2"
			ip_arg=$2
			shift 2
			filters_count=$((filters_count+1))
			;;

		-uri )
			uri_arg=$2
			shift 2
			filters_count=$((filters_count+1))
			;;

		*)
			break
			;;
	esac
done

# Checks for command 
case $1 in
	list-ip)
		list_ip=true
		shift 1
		;;

	list-hosts)
		list_hosts=true
		shift 1
		;;

	list-uri)
		list_uri=true
		shift 1
		;;

	hist-ip)
		hist_ip=true
		shift 1
		;;

	hist-load)
		hist_load=true
		shift 1
		;;

	*)
		;;
esac


if [ "$filters_count" -eq 0 ] && [ ! "$hist_load" ] &&  [ ! "$hist_ip" ] && [ ! "$list_uri" ] && [ ! "$list_hosts" ] && [ ! "$list_ip" ]
then
	logsRead "$@"
	exit 0
fi 

# Filtring the log with all filters
filtered=$(logsRead "$@" | filters)
		
if [ "$list_ip" ]
then
	echo "$filtered" | awk ' { print $1} ' | sort | uniq

elif [ "$list_hosts" ]
then
	adresses=$(echo "$filtered" | awk ' { print $1} ' | sort | uniq )
	listHosts "$adresses"

elif [ "$list_uri" ]
then
	echo "$filtered" | cut -d'"' -f2 | cut -d' ' -f2 | awk ' /^\// ' | sort | uniq

elif [ "$hist_ip" ]
then
	echo "$filtered" | awk ' { print $1} ' | sort | uniq -c | sort -r |
	awk ' {
		printf $2 " " "("$1"):" " "  
		for (i = 0; i < $1; i++)
			printf "#" 
		printf "\n"
		} ' 

elif [ "$hist_load" ]
then
	dateConvert "$(getDateTime "$filtered")" | sed ' s/:/ /1' |
	awk ' { print $1 " " $2":00" } ' | sort -n -k 1.4 -k 1.7 -k 1 | uniq -c |
	awk ' {
		printf $2 " " $3 " " "("$1"):" " "  
		for (i = 0; i < $1; i++)
			printf "#" 
		printf "\n"}' 

else
	echo "$filtered"
fi
